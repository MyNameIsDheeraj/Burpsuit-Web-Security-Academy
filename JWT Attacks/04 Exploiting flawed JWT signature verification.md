# 04. Exploiting flawed JWT signature verification

By design, servers don't usually store any information about the JWTs that they issue. Instead, each token is an entirely **self-contained entity** 📦.

This has several advantages ✅, but also introduces a **fundamental problem** ⚠️ — the server doesn't actually know anything about:

- 📜 The **original contents** of the token
- ✍️ The **original signature** of the token

Therefore, if the server doesn't verify the signature properly, **there's nothing stopping an attacker from making arbitrary changes** ✏️ to the rest of the token.

---

## 🛠 Example Scenario

Consider a JWT containing the following claims:

```json
{
    "username": "carlos",
    "isAdmin": false
}
```

📌 If the server identifies the session based on `username`, **modifying its value might enable an attacker to impersonate other logged-in users** 👤.

Similarly, if the `isAdmin` value is used for access control 🛡, this could provide a **simple vector for privilege escalation** 🚀.

💡 In the first couple of labs, you'll see examples of **how these vulnerabilities might appear in real-world applications** 🌍.

---

## 🎯 Accepting Arbitrary Signatures

JWT libraries typically provide:

- **verify()** ✅ → Verifies the token signature
- **decode()** 📖 → Just decodes the token, without verifying the signature

Example: **Node.js `jsonwebtoken`** library

Occasionally, developers mix these up 😬 and **only pass incoming tokens to the `decode()` method**.

This means the application **doesn't verify the signature at all** ❌.

---

## 🚫 Accepting Tokens with No Signature

Among other things, the JWT header contains an `alg` parameter 🧩:

```json
{
    "alg": "HS256",
    "typ": "JWT"
}
```

📌 This tells the server **which algorithm** was used to sign the token and how to verify it.

⚠️ Problem → The server has no choice but to **implicitly trust user-controllable input** from the token before verifying it.

This means an attacker can **directly influence** how the server decides if the token is trustworthy 🕵️.

---

## 🔐 Unsigned JWTs (alg = none)

JWTs can:

- ✅ Be signed using different algorithms
- ❌ Be left **unsigned** (`alg` = `none`) → an **"unsecured JWT"**

💣 This is dangerous, so servers **usually reject unsigned tokens**.

However, if the check relies on **string parsing**, attackers can bypass it using:

- 🔤 **Mixed capitalization** (e.g., `NoNe`)
- 🔡 **Unexpected encodings**

📌 Even if the token is unsigned, the payload part **must still be terminated with a trailing dot** ➡️ `header.payload.`