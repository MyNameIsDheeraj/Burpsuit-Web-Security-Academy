# 04. Exploiting flawed JWT signature verification

By design, servers don't usually store any information about the JWTs that they issue. Instead, each token is an entirely **self-contained entity** ğŸ“¦.

This has several advantages âœ…, but also introduces a **fundamental problem** âš ï¸ â€” the server doesn't actually know anything about:

- ğŸ“œ The **original contents** of the token
- âœï¸ The **original signature** of the token

Therefore, if the server doesn't verify the signature properly, **there's nothing stopping an attacker from making arbitrary changes** âœï¸ to the rest of the token.

---

## ğŸ›  Example Scenario

Consider a JWT containing the following claims:

```json
{
    "username": "carlos",
    "isAdmin": false
}
```

ğŸ“Œ If the server identifies the session based on `username`, **modifying its value might enable an attacker to impersonate other logged-in users** ğŸ‘¤.

Similarly, if the `isAdmin` value is used for access control ğŸ›¡, this could provide a **simple vector for privilege escalation** ğŸš€.

ğŸ’¡ In the first couple of labs, you'll see examples of **how these vulnerabilities might appear in real-world applications** ğŸŒ.

---

## ğŸ¯ Accepting Arbitrary Signatures

JWT libraries typically provide:

- **verify()** âœ… â†’ Verifies the token signature
- **decode()** ğŸ“– â†’ Just decodes the token, without verifying the signature

Example: **Node.js `jsonwebtoken`** library

Occasionally, developers mix these up ğŸ˜¬ and **only pass incoming tokens to the `decode()` method**.

This means the application **doesn't verify the signature at all** âŒ.

---

## ğŸš« Accepting Tokens with No Signature

Among other things, the JWT header contains an `alg` parameter ğŸ§©:

```json
{
    "alg": "HS256",
    "typ": "JWT"
}
```

ğŸ“Œ This tells the server **which algorithm** was used to sign the token and how to verify it.

âš ï¸ Problem â†’ The server has no choice but to **implicitly trust user-controllable input** from the token before verifying it.

This means an attacker can **directly influence** how the server decides if the token is trustworthy ğŸ•µï¸.

---

## ğŸ” Unsigned JWTs (alg = none)

JWTs can:

- âœ… Be signed using different algorithms
- âŒ Be left **unsigned** (`alg` = `none`) â†’ an **"unsecured JWT"**

ğŸ’£ This is dangerous, so servers **usually reject unsigned tokens**.

However, if the check relies on **string parsing**, attackers can bypass it using:

- ğŸ”¤ **Mixed capitalization** (e.g., `NoNe`)
- ğŸ”¡ **Unexpected encodings**

ğŸ“Œ Even if the token is unsigned, the payload part **must still be terminated with a trailing dot** â¡ï¸ `header.payload.`